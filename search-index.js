var searchIndex = {};
searchIndex['chomp'] = {"items":[[0,"","chomp","Chomp is a fast monadic-style parser combinator library for the Rust programming language. It was\nwritten as the culmination of the experiments detailed in these blog posts:",null,null],[3,"Input","","Linear type containing the parser state, this type is threaded though `bind` and is also the\ninitial type passed to a parser.",null,null],[3,"ParseResult","","The basic return type of a parser.",null,null],[4,"ParseError","","Simple error type returned from `parse_only`.",null,null],[13,"Error","","A parse error occurred.",0,null],[13,"Incomplete","","The parser attempted to read more data than available.",0,null],[5,"parse_only","","Runs the given parser on the supplied finite input.",null,null],[11,"hash","","",1,null],[11,"partial_cmp","","",1,{"inputs":[{"name":"input"},{"name":"input"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"input"},{"name":"input"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"input"},{"name":"input"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"input"},{"name":"input"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"input"},{"name":"input"}],"output":{"name":"bool"}}],[11,"cmp","","",1,{"inputs":[{"name":"input"},{"name":"input"}],"output":{"name":"ordering"}}],[11,"eq","","",1,{"inputs":[{"name":"input"},{"name":"input"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"input"},{"name":"input"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"input"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `Input` to start parsing with.",1,null],[11,"ret","","Returns `t` as a success value in the parsing context.",1,{"inputs":[{"name":"input"},{"name":"t"}],"output":{"name":"parseresult"}}],[11,"err","","Returns `e` as an error value in the parsing context.",1,{"inputs":[{"name":"input"},{"name":"e"}],"output":{"name":"parseresult"}}],[11,"incomplete","","Notifies that a parser has reached the end of the currently supplied slice but requires\nmore data.",1,{"inputs":[{"name":"input"},{"name":"usize"}],"output":{"name":"parseresult"}}],[11,"from_result","","Converts a `Result` into a `ParseResult`, preserving parser state.",1,{"inputs":[{"name":"input"},{"name":"result"}],"output":{"name":"parseresult"}}],[11,"clone","","",1,{"inputs":[{"name":"input"}],"output":{"name":"self"}}],[11,"buffer","","",1,null],[11,"replace","","",1,null],[11,"is_last_slice","","",1,{"inputs":[{"name":"input"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"parseerror"},{"name":"parseerror"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"parseerror"},{"name":"parseerror"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"parseerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",2,null],[11,"partial_cmp","","",2,{"inputs":[{"name":"parseresult"},{"name":"parseresult"}],"output":{"name":"option"}}],[11,"lt","","",2,{"inputs":[{"name":"parseresult"},{"name":"parseresult"}],"output":{"name":"bool"}}],[11,"le","","",2,{"inputs":[{"name":"parseresult"},{"name":"parseresult"}],"output":{"name":"bool"}}],[11,"gt","","",2,{"inputs":[{"name":"parseresult"},{"name":"parseresult"}],"output":{"name":"bool"}}],[11,"ge","","",2,{"inputs":[{"name":"parseresult"},{"name":"parseresult"}],"output":{"name":"bool"}}],[11,"cmp","","",2,{"inputs":[{"name":"parseresult"},{"name":"parseresult"}],"output":{"name":"ordering"}}],[11,"eq","","",2,{"inputs":[{"name":"parseresult"},{"name":"parseresult"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"parseresult"},{"name":"parseresult"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"parseresult"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"bind","","Sequentially composes the result with a parse action ``f``, passing any produced value as\nthe second parameter.",2,{"inputs":[{"name":"parseresult"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"then","","Sequentially composes the result with a parse action ``f``, discarding any produced value.",2,{"inputs":[{"name":"parseresult"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"map","","Applies the function `f` on the contained data if the parser is in a success state.",2,{"inputs":[{"name":"parseresult"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"map_err","","Applies the function `f` on the contained error if the parser is in an error state.",2,{"inputs":[{"name":"parseresult"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"inspect","","Calls the function `f` with a reference of the contained data if the parser is in a success\nstate.",2,{"inputs":[{"name":"parseresult"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"unwrap","","Unwraps a parse result, yielding the content of the success-state.",2,{"inputs":[{"name":"parseresult"}],"output":{"name":"t"}}],[11,"expect","","Unwraps a parse result, yielding the contents of the success state.",2,{"inputs":[{"name":"parseresult"},{"name":"str"}],"output":{"name":"t"}}],[11,"unwrap_err","","Unwraps a parse result, yielding the contents of the error state.",2,{"inputs":[{"name":"parseresult"}],"output":{"name":"e"}}],[11,"into_inner","","",2,{"inputs":[{"name":"parseresult"}],"output":{"name":"inner"}}],[0,"ascii","","Utilities and parsers for dealing with ASCII data in `u8` format.",null,null],[5,"is_lowercase","chomp::ascii","Lowercase ASCII predicate.",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_uppercase","","Uppercase ASCII character predicate.",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_whitespace","","ASCII whitespace predicate.",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_horizontal_space","","A predicate which matches either space (' ') or horizontal tab ('\\t').",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_end_of_line","","A predicate matching eithr a newline ('\\n') or a carriage return ('\\r').",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_digit","","ASCII digit predicate.",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_alpha","","ASCII alphabetic predicate.",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_alphanumeric","","ASCII alphanumeric predicate.",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"skip_whitespace","","Skips over whitespace.",null,{"inputs":[{"name":"input"}],"output":{"name":"u8result"}}],[5,"digit","","Parses a single digit.",null,{"inputs":[{"name":"input"}],"output":{"name":"u8result"}}],[5,"signed","","Parses a number with an optional leading '+' or '-'.",null,{"inputs":[{"name":"input"},{"name":"f"}],"output":{"name":"u8result"}}],[5,"decimal","","Parses a series of digits and converts them to an integer.",null,{"inputs":[{"name":"input"}],"output":{"name":"u8result"}}],[0,"buffer","chomp","Utilities for parsing streams of data.",null,null],[3,"SliceStream","chomp::buffer","Stream implementation for immutable slices.",null,null],[3,"Source","","Manages a buffer and data source pair, enabling efficient parsing from a streaming source.",null,null],[3,"FixedSizeBuffer","","A fixed size buffer.",null,null],[3,"GrowingBuffer","","A buffer which will reallocate to fit the requested amount of data.",null,null],[4,"StreamError","","Error type for parsing using the `Stream` trait.",null,null],[13,"ParseError","","An error occurred in the parser, the given slice indicates the part which failed.",3,null],[13,"Incomplete","","Parser failed to complete with the available data.",3,null],[13,"IoError","","An IO-error occurred while attempting to fill the buffer.",3,null],[13,"EndOfInput","","The last parser completed successfully and there is no more input to parse.",3,null],[13,"Retry","","The last parser failed with an incomplete state, fill the buffer and try again.",3,null],[11,"fmt","","",4,{"inputs":[{"name":"source"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `Source` from a `Read` instance with the default `FixedSizeBuffer` settings.",4,{"inputs":[{"name":"source"},{"name":"r"}],"output":{"name":"self"}}],[11,"from_read","","Creates a new `Source` from `Read` and buffer instances.",4,{"inputs":[{"name":"source"},{"name":"r"},{"name":"b"}],"output":{"name":"self"}}],[11,"from_iter","","Creates a new `Source` from `Iterator` and `Buffer` instances.",4,{"inputs":[{"name":"source"},{"name":"i"},{"name":"b"}],"output":{"name":"self"}}],[11,"with_buffer","","Creates a new `Source` from `DataSource` and `Buffer` instances.",4,{"inputs":[{"name":"source"},{"name":"s"},{"name":"b"}],"output":{"name":"self"}}],[11,"fill","","Attempts to fill the buffer to satisfy the last call to `parse()`.",4,{"inputs":[{"name":"source"}],"output":{"name":"result"}}],[11,"len","","Returns the number of bytes left in the buffer which have not yet been parsed.",4,{"inputs":[{"name":"source"}],"output":{"name":"usize"}}],[11,"is_empty","","If the buffer is empty and the reader has reached the end.",4,{"inputs":[{"name":"source"}],"output":{"name":"bool"}}],[11,"capacity","","Returns the capacity of the underlying buffer.",4,{"inputs":[{"name":"source"}],"output":{"name":"usize"}}],[11,"buffer","","Borrows the remainder of the buffer.",4,null],[11,"reset","","Resets the buffer state, keeping the current buffer contents and cursor position.",4,{"inputs":[{"name":"source"}],"output":null}],[11,"set_autofill","","Changes the setting automatic fill feature, `true` will make the buffer automatically\ncall `fill()` on the next call to `parse()` after a `Retry` was encountered.",4,{"inputs":[{"name":"source"},{"name":"bool"}],"output":null}],[11,"read","","",4,null],[11,"fill_buf","","",4,{"inputs":[{"name":"source"}],"output":{"name":"result"}}],[11,"consume","","",4,{"inputs":[{"name":"source"},{"name":"usize"}],"output":null}],[11,"parse","","",4,{"inputs":[{"name":"source"},{"name":"f"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"fixedsizebuffer"},{"name":"fixedsizebuffer"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"fixedsizebuffer"},{"name":"fixedsizebuffer"}],"output":{"name":"bool"}}],[11,"fmt","","",5,{"inputs":[{"name":"fixedsizebuffer"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a fixed-size buffer with the default buffer size.",5,{"inputs":[{"name":"fixedsizebuffer"}],"output":{"name":"self"}}],[11,"with_size","","Creates a fixed-size buffer with the supplied buffer size.",5,{"inputs":[{"name":"fixedsizebuffer"},{"name":"usize"}],"output":{"name":"self"}}],[11,"deref","","",5,null],[11,"deref_mut","","",5,null],[11,"fill","","",5,{"inputs":[{"name":"fixedsizebuffer"},{"name":"s"}],"output":{"name":"result"}}],[11,"request_space","","",5,{"inputs":[{"name":"fixedsizebuffer"},{"name":"usize"}],"output":null}],[11,"consume","","",5,{"inputs":[{"name":"fixedsizebuffer"},{"name":"usize"}],"output":null}],[11,"len","","",5,{"inputs":[{"name":"fixedsizebuffer"}],"output":{"name":"usize"}}],[11,"capacity","","",5,{"inputs":[{"name":"fixedsizebuffer"}],"output":{"name":"usize"}}],[11,"fmt","","",6,{"inputs":[{"name":"growingbuffer"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new unlimited `GrowingBuffer`.",6,{"inputs":[{"name":"growingbuffer"}],"output":{"name":"self"}}],[11,"with_limit","","Creates a new `GrowingBuffer` with the specified limit.",6,{"inputs":[{"name":"growingbuffer"},{"name":"usize"}],"output":{"name":"self"}}],[11,"deref","","",6,null],[11,"deref_mut","","",6,null],[11,"fill","","",6,{"inputs":[{"name":"growingbuffer"},{"name":"s"}],"output":{"name":"result"}}],[11,"request_space","","",6,{"inputs":[{"name":"growingbuffer"},{"name":"usize"}],"output":null}],[11,"consume","","",6,{"inputs":[{"name":"growingbuffer"},{"name":"usize"}],"output":null}],[11,"len","","",6,{"inputs":[{"name":"growingbuffer"}],"output":{"name":"usize"}}],[11,"capacity","","",6,{"inputs":[{"name":"growingbuffer"}],"output":{"name":"usize"}}],[11,"hash","","",7,null],[11,"eq","","",7,{"inputs":[{"name":"slicestream"},{"name":"slicestream"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"slicestream"},{"name":"slicestream"}],"output":{"name":"bool"}}],[11,"fmt","","",7,{"inputs":[{"name":"slicestream"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new stream from an immutable slice.",7,null],[11,"len","","The number of bytes left in the buffer",7,{"inputs":[{"name":"slicestream"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns true if no more bytes are available",7,{"inputs":[{"name":"slicestream"}],"output":{"name":"bool"}}],[11,"parse","","",7,{"inputs":[{"name":"slicestream"},{"name":"f"}],"output":{"name":"result"}}],[0,"data_source","","Implementation of datasources for `Source`.",null,null],[3,"ReadDataSource","chomp::buffer::data_source","Implementation of `DataSource` for `io::Read` instances.",null,null],[3,"IteratorDataSource","","Implementation of `DataSource` for `Iterator`.",null,null],[8,"DataSource","","Abstraction over `io::Read`, `Iterator` and others.",null,null],[16,"Item","","The type of items this data source produces.",8,null],[10,"read","","Populates the supplied buffer with data, returns the number of items written.",8,null],[11,"fmt","","",9,{"inputs":[{"name":"readdatasource"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `ReadDataSource` from a `Read` instance.",9,{"inputs":[{"name":"readdatasource"},{"name":"r"}],"output":{"name":"self"}}],[11,"into_inner","","Consumes self to reveal the underlying `Read` instance.",9,{"inputs":[{"name":"readdatasource"}],"output":{"name":"r"}}],[11,"read","","",9,null],[11,"fmt","","",10,{"inputs":[{"name":"iteratordatasource"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Creates a new `IteratorDataSource` from an `Iterator` instance.",10,{"inputs":[{"name":"iteratordatasource"},{"name":"i"}],"output":{"name":"self"}}],[11,"into_inner","","Consumes self to reveal the underlying `Iterator` instance.",10,{"inputs":[{"name":"iteratordatasource"}],"output":{"name":"i"}}],[11,"read","","",10,null],[8,"Buffer","chomp::buffer","Trait all parser buffers implement.",null,null],[10,"fill","","Attempt to fill the buffer using the closure `F`.",11,{"inputs":[{"name":"buffer"},{"name":"s"}],"output":{"name":"result"}}],[10,"request_space","","Buffer attempts to clear space for additional items.",11,{"inputs":[{"name":"buffer"},{"name":"usize"}],"output":null}],[10,"consume","","Consumes the given amount of bytes, must be less than or equal to `len()`.",11,{"inputs":[{"name":"buffer"},{"name":"usize"}],"output":null}],[10,"len","","Returns the number of bytes left in the buffer.",11,{"inputs":[{"name":"buffer"}],"output":{"name":"usize"}}],[11,"is_empty","","If the buffer has no more data.",11,{"inputs":[{"name":"buffer"}],"output":{"name":"bool"}}],[10,"capacity","","Returns the maximum amount of data which can be stored",11,{"inputs":[{"name":"buffer"}],"output":{"name":"usize"}}],[8,"Stream","","Trait wrapping the state management in reading from a data source while parsing.",null,null],[16,"Item","","The input item type, usually depending on which `DataSource` is used.",12,null],[10,"parse","","Attempts to run the supplied parser `F` once on the currently populated data in this\nstream, providing a borrow of the inner data storage.",12,{"inputs":[{"name":"stream"},{"name":"f"}],"output":{"name":"result"}}],[8,"IntoStream","","Trait for conversion into a `Stream`.",null,null],[16,"Item","","The input item type provided by the stream.",13,null],[16,"Into","","The `Stream` instance type.",13,null],[10,"into_stream","","Convert self into a `Stream`.",13,{"inputs":[{"name":"intostream"}],"output":{"name":"into"}}],[11,"fmt","","",3,{"inputs":[{"name":"streamerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"streamerror"},{"name":"streamerror"}],"output":{"name":"bool"}}],[11,"from","","",3,{"inputs":[{"name":"streamerror"},{"name":"parseerror"}],"output":{"name":"self"}}],[0,"parsers","chomp","Basic parsers.",null,null],[4,"Error","chomp::parsers","Common error for the basic Chomp parsers, verbose version.",null,null],[13,"Expected","","Expected a specific token",14,null],[13,"Unexpected","","Did not expect the token present in the input stream",14,null],[13,"String","","Expected a specific string of tokens",14,null],[5,"any","","Matches any item, returning it if present.",null,{"inputs":[{"name":"input"}],"output":{"name":"simpleresult"}}],[5,"satisfy","","Matches an item using ``f``, the item is returned if ``f`` yields true, otherwise this parser\nfails.",null,{"inputs":[{"name":"input"},{"name":"f"}],"output":{"name":"simpleresult"}}],[5,"satisfy_with","","Reads a single token, applies the transformation `F` and then succeeds with the transformed\nvaleue if the predicate `P` yields true on this transformed value.",null,{"inputs":[{"name":"input"},{"name":"f"},{"name":"p"}],"output":{"name":"simpleresult"}}],[5,"token","","Matches a single token, returning the match on success.",null,{"inputs":[{"name":"input"},{"name":"i"}],"output":{"name":"simpleresult"}}],[5,"not_token","","Matches a single token as long as it is not equal to `t`, returning the match on success.",null,{"inputs":[{"name":"input"},{"name":"i"}],"output":{"name":"simpleresult"}}],[5,"peek","","Matches any item but does not consume it, on success it gives ``Some`` but if no input remains\n``None`` is produced.",null,{"inputs":[{"name":"input"}],"output":{"name":"simpleresult"}}],[5,"peek_next","","Matches any item but does not consume it.",null,{"inputs":[{"name":"input"}],"output":{"name":"simpleresult"}}],[5,"take","","Matches ``num`` items no matter what they are, returning a slice of the matched items.",null,{"inputs":[{"name":"input"},{"name":"usize"}],"output":{"name":"simpleresult"}}],[5,"take_while","","Matches all items while ``f`` returns false, returns a slice of all the matched items.",null,{"inputs":[{"name":"input"},{"name":"f"}],"output":{"name":"simpleresult"}}],[5,"take_while1","","Matches all items while ``f`` returns true, if at least one item matched this parser succeeds\nand returns a slice of all the matched items.",null,{"inputs":[{"name":"input"},{"name":"f"}],"output":{"name":"simpleresult"}}],[5,"take_till","","Matches all items until ``f`` returns true, all items to that point will be returned as a slice\nupon success.",null,{"inputs":[{"name":"input"},{"name":"f"}],"output":{"name":"simpleresult"}}],[5,"scan","","The predicate consumes and transforms a state argument, this parser will match everything until\nthe predicate returns `None`.",null,{"inputs":[{"name":"input"},{"name":"s"},{"name":"f"}],"output":{"name":"simpleresult"}}],[5,"run_scanner","","Like `scan` but generalized to return the final state of the scanner.",null,{"inputs":[{"name":"input"},{"name":"s"},{"name":"f"}],"output":{"name":"simpleresult"}}],[5,"take_remainder","","Matches the remainder of the buffer and returns it, always succeeds.",null,{"inputs":[{"name":"input"}],"output":{"name":"simpleresult"}}],[5,"string","","Matches the given slice against the parser, returning the matched slice upon success.",null,null],[5,"eof","","Matches the end of the input.",null,{"inputs":[{"name":"input"}],"output":{"name":"simpleresult"}}],[11,"hash","","",14,null],[11,"partial_cmp","","",14,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"option"}}],[11,"lt","","",14,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"bool"}}],[11,"le","","",14,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"bool"}}],[11,"gt","","",14,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"bool"}}],[11,"ge","","",14,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"bool"}}],[11,"cmp","","",14,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"ordering"}}],[11,"eq","","",14,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"bool"}}],[11,"ne","","",14,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"bool"}}],[11,"fmt","","",14,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"new","","Creates a new Unexpected error.",14,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"fmt","","",14,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",14,{"inputs":[{"name":"error"}],"output":{"name":"str"}}],[0,"combinators","chomp","Basic combinators.",null,null],[5,"count","chomp::combinators","Applies the parser ``p`` exactly ``num`` times collecting all items into `T: FromIterator`.",null,{"inputs":[{"name":"input"},{"name":"usize"},{"name":"f"}],"output":{"name":"parseresult"}}],[5,"option","","Tries the parser ``f``, on success it yields the parsed value, on failure ``default`` will be\nyielded instead.",null,{"inputs":[{"name":"input"},{"name":"f"},{"name":"t"}],"output":{"name":"parseresult"}}],[5,"or","","Tries to match the parser ``f``, if ``f`` fails it tries ``g``. Returns the success value of\n the first match, otherwise the error of the last one if both fail.",null,{"inputs":[{"name":"input"},{"name":"f"},{"name":"g"}],"output":{"name":"parseresult"}}],[5,"many","","Parses many instances of ``f`` until it does no longer match, collecting all matches into the\ntype `T: FromIterator`.",null,{"inputs":[{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[5,"many1","","Parses at least one instance of ``f`` and continues until it does no longer match, collecting\n all matches into the type `T: FromIterator`.",null,{"inputs":[{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[5,"sep_by","","Applies the parser `R` zero or more times, separated by the parser `F`. All matches from `R`\nwill be collected into the type `T: FromIterator`.",null,{"inputs":[{"name":"input"},{"name":"r"},{"name":"f"}],"output":{"name":"parseresult"}}],[5,"sep_by1","","Applies the parser `R` one or more times, separated by the parser `F`. All matches from `R`\nwill be collected into the type `T: FromIterator`.",null,{"inputs":[{"name":"input"},{"name":"r"},{"name":"f"}],"output":{"name":"parseresult"}}],[5,"many_till","","Applies the parser `R` multiple times until the parser `F` succeeds and returns a\n`T: FromIterator` populated by the values yielded by `R`. Consumes the matched part of `F`.",null,{"inputs":[{"name":"input"},{"name":"r"},{"name":"f"}],"output":{"name":"parseresult"}}],[5,"skip_many","","Runs the given parser until it fails, discarding matched input.",null,{"inputs":[{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[5,"skip_many1","","Runs the given parser until it fails, discarding matched input, expects at least one match.",null,{"inputs":[{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[5,"matched_by","","Returns the result of the given parser as well as the slice which matched it.",null,{"inputs":[{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[5,"look_ahead","","Applies the parser `F` without consuming any input.",null,{"inputs":[{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[0,"bounded","","Bounded versions of combinators.",null,null],[5,"many","chomp::combinators::bounded","Applies the parser `F` multiple times until it fails or the maximum value of the range has\nbeen reached, collecting the successful values into a `T: FromIterator`.",null,{"inputs":[{"name":"input"},{"name":"r"},{"name":"f"}],"output":{"name":"parseresult"}}],[5,"skip_many","","Applies the parser `F` multiple times until it fails or the maximum value of the range has\nbeen reached, throwing away any produced value.",null,{"inputs":[{"name":"input"},{"name":"r"},{"name":"f"}],"output":{"name":"parseresult"}}],[5,"many_till","","Applies the parser `P` multiple times until the parser `F` succeeds and returns a value\npopulated by the values yielded by `P`. Consumes the matched part of `F`. If `F` does not\nsucceed within the given range `R` this combinator will propagate any failure from `P`.",null,{"inputs":[{"name":"input"},{"name":"r"},{"name":"p"},{"name":"f"}],"output":{"name":"parseresult"}}],[8,"BoundedRange","","Trait for applying a parser multiple times based on a range.",null,null],[10,"parse_many","","Applies the parser `F` multiple times until it fails or the maximum value of the range has\nbeen reached, collecting the successful values into a `T: FromIterator`.",15,{"inputs":[{"name":"boundedrange"},{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[10,"skip_many","","Applies the parser `F` multiple times until it fails or the maximum value of the range has\nbeen reached, throwing away any produced value.",15,{"inputs":[{"name":"boundedrange"},{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[10,"many_till","","Applies the parser `P` multiple times until the parser `F` succeeds and returns a value\npopulated by the values yielded by `P`. Consumes the matched part of `F`. If `F` does not\nsucceed within the given range `R` this combinator will propagate any failure from `P`.",15,{"inputs":[{"name":"boundedrange"},{"name":"input"},{"name":"r"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"parse_many","core::ops","",16,{"inputs":[{"name":"range"},{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"skip_many","","",16,{"inputs":[{"name":"range"},{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"many_till","","",16,{"inputs":[{"name":"range"},{"name":"input"},{"name":"r"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"parse_many","","",17,{"inputs":[{"name":"rangefrom"},{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"skip_many","","",17,{"inputs":[{"name":"rangefrom"},{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"many_till","","",17,{"inputs":[{"name":"rangefrom"},{"name":"input"},{"name":"r"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"parse_many","","",18,{"inputs":[{"name":"rangefull"},{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"skip_many","","",18,{"inputs":[{"name":"rangefull"},{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"many_till","","",18,{"inputs":[{"name":"rangefull"},{"name":"input"},{"name":"r"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"parse_many","","",19,{"inputs":[{"name":"rangeto"},{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"skip_many","","",19,{"inputs":[{"name":"rangeto"},{"name":"input"},{"name":"f"}],"output":{"name":"parseresult"}}],[11,"many_till","","",19,{"inputs":[{"name":"rangeto"},{"name":"input"},{"name":"r"},{"name":"f"}],"output":{"name":"parseresult"}}],[0,"primitives","chomp","Module used to construct fundamental parsers and combinators.",null,null],[4,"State","chomp::primitives","**Primitive:** Primitive inner type containing the parse-state.",null,null],[13,"Data","","Successful parser state, first item is the input state and the second item is the contained\nvalue.",20,null],[13,"Error","","Parse error state, first item is a slice from where the error occurred in the input buffer\nto the end of the input buffer and the second item is the error value.",20,null],[13,"Incomplete","","Incomplete state, a parser attempted to request more data than available in the slice, the\nprovided number is a guess at how many items are needed.",20,null],[0,"input","","Input utilities.",null,null],[5,"new","chomp::primitives::input","**Primitive:** Creates a new input from the given state and buffer.",null,null],[17,"DEFAULT","","Default (empty) input state.",null,null],[17,"END_OF_INPUT","","If set the current slice of input is the last one.",null,null],[0,"parse_result","chomp::primitives","ParseResult utilities.",null,null],[5,"new","chomp::primitives::parse_result","**Primitive:** Creates a new `ParseResult`.",null,{"inputs":[{"name":"state"}],"output":{"name":"parseresult"}}],[8,"InputBuffer","chomp::primitives","**Primitive:** Trait exposing the buffer of `Input`.",null,null],[16,"Item","","The type of each element of the buffer.",21,null],[10,"buffer","","Reveals the internal buffer containig the remainder of the input.",21,null],[10,"replace","","Modifies the inner data without leaving the `Input` context.",21,null],[10,"is_last_slice","","Returns true if this is the last available slice of the input.",21,{"inputs":[{"name":"inputbuffer"}],"output":{"name":"bool"}}],[8,"InputClone","","**Primitive:** Trait limiting the use of `Clone` for `Input`.",null,null],[10,"clone","","Creates a clone of the instance.",22,{"inputs":[{"name":"inputclone"}],"output":{"name":"self"}}],[8,"IntoInner","","**Primitive:** Consumes self and reveals the inner state.",null,null],[16,"Inner","","The inner type to be revealed.",23,null],[10,"into_inner","","**Primitive:** Consumes self and reveals the inner state.",23,{"inputs":[{"name":"intoinner"}],"output":{"name":"inner"}}],[6,"SimpleResult","chomp","Result returned from the basic parsers.",null,null],[6,"U8Result","","Result for dealing with the basic parsers when parsing a stream of `u8`.",null,null],[14,"parse!","","Macro emulating `do`-notation for the parser monad, automatically threading the linear type.",null,null],[14,"parser!","","Macro wrapping an invocation to ``parse!`` in a closure, useful for creating parsers inline.",null,null],[11,"hash","chomp::primitives","",20,null],[11,"partial_cmp","","",20,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"option"}}],[11,"lt","","",20,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"le","","",20,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"gt","","",20,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"ge","","",20,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"cmp","","",20,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"ordering"}}],[11,"eq","","",20,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"ne","","",20,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"fmt","","",20,{"inputs":[{"name":"state"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"is_empty","chomp::buffer","If the buffer has no more data.",11,{"inputs":[{"name":"buffer"}],"output":{"name":"bool"}}]],"paths":[[4,"ParseError"],[3,"Input"],[3,"ParseResult"],[4,"StreamError"],[3,"Source"],[3,"FixedSizeBuffer"],[3,"GrowingBuffer"],[3,"SliceStream"],[8,"DataSource"],[3,"ReadDataSource"],[3,"IteratorDataSource"],[8,"Buffer"],[8,"Stream"],[8,"IntoStream"],[4,"Error"],[8,"BoundedRange"],[3,"Range"],[3,"RangeFrom"],[3,"RangeFull"],[3,"RangeTo"],[4,"State"],[8,"InputBuffer"],[8,"InputClone"],[8,"IntoInner"]]};
searchIndex['conv'] = {"items":[[0,"","conv","This crate provides a number of conversion traits with more specific semantics than those provided by `as` or `From`/`Into`.",null,null],[4,"DefaultApprox","","The \"default\" approximation scheme.  This scheme does whatever would generally be expected of a lossy conversion, assuming no additional context or instruction is given.",null,null],[4,"Wrapping","","This scheme is used to convert a value by \"wrapping\" it into a narrower range.",null,null],[4,"RoundToNearest","","This scheme is used to convert a value by rounding it to the nearest representable value, with ties rounding away from zero.",null,null],[4,"RoundToNegInf","","This scheme is used to convert a value by rounding it toward negative infinity to the nearest representable value.",null,null],[4,"RoundToPosInf","","This scheme is used to convert a value by rounding it toward positive infinity to the nearest representable value.",null,null],[4,"RoundToZero","","This scheme is used to convert a value by rounding it toward zero to the nearest representable value.",null,null],[0,"macros","","This module provides convenience macros to help with implementing the conversion traits.",null,null],[0,"prelude","","Publicly re-exports the most generally useful set of items.",null,null],[0,"errors","","This module defines the various error types that can be produced by a failed conversion.",null,null],[3,"Unrepresentable","conv::errors","Indicates that the conversion failed because the value was not representable.",null,null],[3,"NegOverflow","","Indicates that the conversion failed due to a negative overflow.",null,null],[3,"PosOverflow","","Indicates that the conversion failed due to a positive overflow.",null,null],[4,"GeneralError","","A general error enumeration that subsumes all other conversion errors.",null,null],[13,"NegOverflow","","Input was too negative for the target type.",0,null],[13,"PosOverflow","","Input was too positive for the target type.",0,null],[13,"Unrepresentable","","Input was not representable in the target type.",0,null],[4,"GeneralErrorKind","","A general error enumeration that subsumes all other conversion errors, but discards all input payloads the errors may be carrying.",null,null],[13,"NegOverflow","","Input was too negative for the target type.",1,null],[13,"PosOverflow","","Input was too positive for the target type.",1,null],[13,"Unrepresentable","","Input was not representable in the target type.",1,null],[4,"NoError","","Indicates that it is not possible for the conversion to fail.",null,null],[4,"FloatError","","Indicates that a conversion from a floating point type failed.",null,null],[13,"NegOverflow","","Input was too negative for the target type.",2,null],[13,"PosOverflow","","Input was too positive for the target type.",2,null],[13,"NotANumber","","Input was not-a-number, which the target type could not represent.",2,null],[4,"RangeError","","Indicates that a conversion failed due to a range error.",null,null],[13,"NegOverflow","","Input was too negative for the target type.",3,null],[13,"PosOverflow","","Input was too positive the target type.",3,null],[4,"RangeErrorKind","","Indicates that a conversion failed due to a range error.",null,null],[13,"NegOverflow","","Input was too negative for the target type.",4,null],[13,"PosOverflow","","Input was too positive for the target type.",4,null],[8,"Saturate","","Saturates a `Result`.",null,null],[16,"Output","","The result of saturating.",5,null],[10,"saturate","","Replaces an overflow error with a saturated value.",5,{"inputs":[{"name":"saturate"}],"output":{"name":"output"}}],[8,"UnwrapOk","","Safely unwrap a `Result` that cannot contain an error.",null,null],[10,"unwrap_ok","","Unwraps a `Result` without possibility of failing.",6,{"inputs":[{"name":"unwrapok"}],"output":{"name":"t"}}],[8,"UnwrapOrInf","","Unwrap a conversion by saturating to infinity.",null,null],[16,"Output","","The result of unwrapping.",7,null],[10,"unwrap_or_inf","","Either unwraps the successfully converted value, or saturates to infinity in the \"direction\" of overflow.",7,{"inputs":[{"name":"unwraporinf"}],"output":{"name":"output"}}],[8,"UnwrapOrInvalid","","Unwrap a conversion by replacing a failure with an invalid sentinel value.",null,null],[16,"Output","","The result of unwrapping.",8,null],[10,"unwrap_or_invalid","","Either unwraps the successfully converted value, or returns the output type's invalid sentinel value.",8,{"inputs":[{"name":"unwraporinvalid"}],"output":{"name":"output"}}],[8,"UnwrapOrSaturate","","Unwrap a conversion by saturating.",null,null],[16,"Output","","The result of unwrapping.",9,null],[10,"unwrap_or_saturate","","Either unwraps the successfully converted value, or saturates in the \"direction\" of overflow.",9,{"inputs":[{"name":"unwraporsaturate"}],"output":{"name":"output"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"generalerror"},{"name":"generalerror"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"generalerror"},{"name":"generalerror"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"generalerror"},{"name":"generalerror"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"generalerror"},{"name":"generalerror"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"generalerror"},{"name":"generalerror"}],"output":{"name":"bool"}}],[11,"cmp","","",0,{"inputs":[{"name":"generalerror"},{"name":"generalerror"}],"output":{"name":"ordering"}}],[11,"eq","","",0,{"inputs":[{"name":"generalerror"},{"name":"generalerror"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"generalerror"},{"name":"generalerror"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"generalerror"}],"output":{"name":"generalerror"}}],[11,"into_inner","","Returns the value stored in this error.",0,{"inputs":[{"name":"generalerror"}],"output":{"name":"t"}}],[11,"fmt","","",0,{"inputs":[{"name":"generalerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",0,{"inputs":[{"name":"generalerror"},{"name":"noerror"}],"output":{"name":"self"}}],[11,"fmt","","",0,{"inputs":[{"name":"generalerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",0,{"inputs":[{"name":"generalerror"}],"output":{"name":"str"}}],[11,"from","","",0,{"inputs":[{"name":"generalerror"},{"name":"unrepresentable"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"generalerror"},{"name":"negoverflow"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"generalerror"},{"name":"posoverflow"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"generalerror"},{"name":"rangeerror"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"generalerror"},{"name":"floaterror"}],"output":{"name":"generalerror"}}],[11,"fmt","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"generalerrorkind"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"generalerrorkind"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"generalerrorkind"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"generalerrorkind"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"generalerrorkind"}],"output":{"name":"bool"}}],[11,"cmp","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"generalerrorkind"}],"output":{"name":"ordering"}}],[11,"eq","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"generalerrorkind"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"generalerrorkind"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"generalerrorkind"}],"output":{"name":"generalerrorkind"}}],[11,"from","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"noerror"}],"output":{"name":"self"}}],[11,"fmt","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",1,{"inputs":[{"name":"generalerrorkind"}],"output":{"name":"str"}}],[11,"from","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"unrepresentable"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"negoverflow"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"posoverflow"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"rangeerrorkind"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"rangeerror"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"generalerror"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"generalerrorkind"},{"name":"floaterror"}],"output":{"name":"generalerrorkind"}}],[11,"fmt","","",10,{"inputs":[{"name":"noerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"partial_cmp","","",10,{"inputs":[{"name":"noerror"},{"name":"noerror"}],"output":{"name":"option"}}],[11,"lt","","",10,{"inputs":[{"name":"noerror"},{"name":"noerror"}],"output":{"name":"bool"}}],[11,"le","","",10,{"inputs":[{"name":"noerror"},{"name":"noerror"}],"output":{"name":"bool"}}],[11,"gt","","",10,{"inputs":[{"name":"noerror"},{"name":"noerror"}],"output":{"name":"bool"}}],[11,"ge","","",10,{"inputs":[{"name":"noerror"},{"name":"noerror"}],"output":{"name":"bool"}}],[11,"cmp","","",10,{"inputs":[{"name":"noerror"},{"name":"noerror"}],"output":{"name":"ordering"}}],[11,"eq","","",10,{"inputs":[{"name":"noerror"},{"name":"noerror"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"noerror"},{"name":"noerror"}],"output":{"name":"bool"}}],[11,"clone","","",10,{"inputs":[{"name":"noerror"}],"output":{"name":"noerror"}}],[11,"fmt","","",10,{"inputs":[{"name":"noerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",10,{"inputs":[{"name":"noerror"}],"output":{"name":"str"}}],[11,"partial_cmp","","",11,{"inputs":[{"name":"unrepresentable"},{"name":"unrepresentable"}],"output":{"name":"option"}}],[11,"lt","","",11,{"inputs":[{"name":"unrepresentable"},{"name":"unrepresentable"}],"output":{"name":"bool"}}],[11,"le","","",11,{"inputs":[{"name":"unrepresentable"},{"name":"unrepresentable"}],"output":{"name":"bool"}}],[11,"gt","","",11,{"inputs":[{"name":"unrepresentable"},{"name":"unrepresentable"}],"output":{"name":"bool"}}],[11,"ge","","",11,{"inputs":[{"name":"unrepresentable"},{"name":"unrepresentable"}],"output":{"name":"bool"}}],[11,"cmp","","",11,{"inputs":[{"name":"unrepresentable"},{"name":"unrepresentable"}],"output":{"name":"ordering"}}],[11,"eq","","",11,{"inputs":[{"name":"unrepresentable"},{"name":"unrepresentable"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"unrepresentable"},{"name":"unrepresentable"}],"output":{"name":"bool"}}],[11,"clone","","",11,{"inputs":[{"name":"unrepresentable"}],"output":{"name":"unrepresentable"}}],[11,"into_inner","","Returns the value stored in this error.",11,{"inputs":[{"name":"unrepresentable"}],"output":{"name":"t"}}],[11,"fmt","","",11,{"inputs":[{"name":"unrepresentable"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",11,{"inputs":[{"name":"unrepresentable"},{"name":"noerror"}],"output":{"name":"self"}}],[11,"fmt","","",11,{"inputs":[{"name":"unrepresentable"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",11,{"inputs":[{"name":"unrepresentable"}],"output":{"name":"str"}}],[11,"partial_cmp","","",12,{"inputs":[{"name":"negoverflow"},{"name":"negoverflow"}],"output":{"name":"option"}}],[11,"lt","","",12,{"inputs":[{"name":"negoverflow"},{"name":"negoverflow"}],"output":{"name":"bool"}}],[11,"le","","",12,{"inputs":[{"name":"negoverflow"},{"name":"negoverflow"}],"output":{"name":"bool"}}],[11,"gt","","",12,{"inputs":[{"name":"negoverflow"},{"name":"negoverflow"}],"output":{"name":"bool"}}],[11,"ge","","",12,{"inputs":[{"name":"negoverflow"},{"name":"negoverflow"}],"output":{"name":"bool"}}],[11,"cmp","","",12,{"inputs":[{"name":"negoverflow"},{"name":"negoverflow"}],"output":{"name":"ordering"}}],[11,"eq","","",12,{"inputs":[{"name":"negoverflow"},{"name":"negoverflow"}],"output":{"name":"bool"}}],[11,"ne","","",12,{"inputs":[{"name":"negoverflow"},{"name":"negoverflow"}],"output":{"name":"bool"}}],[11,"clone","","",12,{"inputs":[{"name":"negoverflow"}],"output":{"name":"negoverflow"}}],[11,"into_inner","","Returns the value stored in this error.",12,{"inputs":[{"name":"negoverflow"}],"output":{"name":"t"}}],[11,"fmt","","",12,{"inputs":[{"name":"negoverflow"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",12,{"inputs":[{"name":"negoverflow"},{"name":"noerror"}],"output":{"name":"self"}}],[11,"fmt","","",12,{"inputs":[{"name":"negoverflow"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",12,{"inputs":[{"name":"negoverflow"}],"output":{"name":"str"}}],[11,"partial_cmp","","",13,{"inputs":[{"name":"posoverflow"},{"name":"posoverflow"}],"output":{"name":"option"}}],[11,"lt","","",13,{"inputs":[{"name":"posoverflow"},{"name":"posoverflow"}],"output":{"name":"bool"}}],[11,"le","","",13,{"inputs":[{"name":"posoverflow"},{"name":"posoverflow"}],"output":{"name":"bool"}}],[11,"gt","","",13,{"inputs":[{"name":"posoverflow"},{"name":"posoverflow"}],"output":{"name":"bool"}}],[11,"ge","","",13,{"inputs":[{"name":"posoverflow"},{"name":"posoverflow"}],"output":{"name":"bool"}}],[11,"cmp","","",13,{"inputs":[{"name":"posoverflow"},{"name":"posoverflow"}],"output":{"name":"ordering"}}],[11,"eq","","",13,{"inputs":[{"name":"posoverflow"},{"name":"posoverflow"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"posoverflow"},{"name":"posoverflow"}],"output":{"name":"bool"}}],[11,"clone","","",13,{"inputs":[{"name":"posoverflow"}],"output":{"name":"posoverflow"}}],[11,"into_inner","","Returns the value stored in this error.",13,{"inputs":[{"name":"posoverflow"}],"output":{"name":"t"}}],[11,"fmt","","",13,{"inputs":[{"name":"posoverflow"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",13,{"inputs":[{"name":"posoverflow"},{"name":"noerror"}],"output":{"name":"self"}}],[11,"fmt","","",13,{"inputs":[{"name":"posoverflow"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",13,{"inputs":[{"name":"posoverflow"}],"output":{"name":"str"}}],[11,"partial_cmp","","",2,{"inputs":[{"name":"floaterror"},{"name":"floaterror"}],"output":{"name":"option"}}],[11,"lt","","",2,{"inputs":[{"name":"floaterror"},{"name":"floaterror"}],"output":{"name":"bool"}}],[11,"le","","",2,{"inputs":[{"name":"floaterror"},{"name":"floaterror"}],"output":{"name":"bool"}}],[11,"gt","","",2,{"inputs":[{"name":"floaterror"},{"name":"floaterror"}],"output":{"name":"bool"}}],[11,"ge","","",2,{"inputs":[{"name":"floaterror"},{"name":"floaterror"}],"output":{"name":"bool"}}],[11,"cmp","","",2,{"inputs":[{"name":"floaterror"},{"name":"floaterror"}],"output":{"name":"ordering"}}],[11,"eq","","",2,{"inputs":[{"name":"floaterror"},{"name":"floaterror"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"floaterror"},{"name":"floaterror"}],"output":{"name":"bool"}}],[11,"clone","","",2,{"inputs":[{"name":"floaterror"}],"output":{"name":"floaterror"}}],[11,"into_inner","","Returns the value stored in this error.",2,{"inputs":[{"name":"floaterror"}],"output":{"name":"t"}}],[11,"fmt","","",2,{"inputs":[{"name":"floaterror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",2,{"inputs":[{"name":"floaterror"},{"name":"noerror"}],"output":{"name":"self"}}],[11,"fmt","","",2,{"inputs":[{"name":"floaterror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",2,{"inputs":[{"name":"floaterror"}],"output":{"name":"str"}}],[11,"from","","",2,{"inputs":[{"name":"floaterror"},{"name":"negoverflow"}],"output":{"name":"self"}}],[11,"from","","",2,{"inputs":[{"name":"floaterror"},{"name":"posoverflow"}],"output":{"name":"self"}}],[11,"from","","",2,{"inputs":[{"name":"floaterror"},{"name":"rangeerror"}],"output":{"name":"self"}}],[11,"partial_cmp","","",3,{"inputs":[{"name":"rangeerror"},{"name":"rangeerror"}],"output":{"name":"option"}}],[11,"lt","","",3,{"inputs":[{"name":"rangeerror"},{"name":"rangeerror"}],"output":{"name":"bool"}}],[11,"le","","",3,{"inputs":[{"name":"rangeerror"},{"name":"rangeerror"}],"output":{"name":"bool"}}],[11,"gt","","",3,{"inputs":[{"name":"rangeerror"},{"name":"rangeerror"}],"output":{"name":"bool"}}],[11,"ge","","",3,{"inputs":[{"name":"rangeerror"},{"name":"rangeerror"}],"output":{"name":"bool"}}],[11,"cmp","","",3,{"inputs":[{"name":"rangeerror"},{"name":"rangeerror"}],"output":{"name":"ordering"}}],[11,"eq","","",3,{"inputs":[{"name":"rangeerror"},{"name":"rangeerror"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"rangeerror"},{"name":"rangeerror"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"rangeerror"}],"output":{"name":"rangeerror"}}],[11,"into_inner","","Returns the value stored in this error.",3,{"inputs":[{"name":"rangeerror"}],"output":{"name":"t"}}],[11,"fmt","","",3,{"inputs":[{"name":"rangeerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",3,{"inputs":[{"name":"rangeerror"},{"name":"noerror"}],"output":{"name":"self"}}],[11,"fmt","","",3,{"inputs":[{"name":"rangeerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",3,{"inputs":[{"name":"rangeerror"}],"output":{"name":"str"}}],[11,"from","","",3,{"inputs":[{"name":"rangeerror"},{"name":"negoverflow"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"rangeerror"},{"name":"posoverflow"}],"output":{"name":"self"}}],[11,"fmt","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"partial_cmp","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"rangeerrorkind"}],"output":{"name":"option"}}],[11,"lt","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"rangeerrorkind"}],"output":{"name":"bool"}}],[11,"le","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"rangeerrorkind"}],"output":{"name":"bool"}}],[11,"gt","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"rangeerrorkind"}],"output":{"name":"bool"}}],[11,"ge","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"rangeerrorkind"}],"output":{"name":"bool"}}],[11,"cmp","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"rangeerrorkind"}],"output":{"name":"ordering"}}],[11,"eq","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"rangeerrorkind"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"rangeerrorkind"}],"output":{"name":"bool"}}],[11,"clone","","",4,{"inputs":[{"name":"rangeerrorkind"}],"output":{"name":"rangeerrorkind"}}],[11,"from","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"noerror"}],"output":{"name":"self"}}],[11,"fmt","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",4,{"inputs":[{"name":"rangeerrorkind"}],"output":{"name":"str"}}],[11,"from","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"negoverflow"}],"output":{"name":"self"}}],[11,"from","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"posoverflow"}],"output":{"name":"self"}}],[11,"from","","",4,{"inputs":[{"name":"rangeerrorkind"},{"name":"rangeerror"}],"output":{"name":"self"}}],[11,"saturate","core::result","",14,{"inputs":[{"name":"result"}],"output":{"name":"output"}}],[11,"saturate","","",14,{"inputs":[{"name":"result"}],"output":{"name":"output"}}],[11,"saturate","","",14,{"inputs":[{"name":"result"}],"output":{"name":"output"}}],[11,"unwrap_ok","","",14,{"inputs":[{"name":"result"}],"output":{"name":"t"}}],[11,"unwrap_or_inf","","",14,{"inputs":[{"name":"result"}],"output":{"name":"t"}}],[11,"unwrap_or_invalid","","",14,{"inputs":[{"name":"result"}],"output":{"name":"t"}}],[11,"unwrap_or_saturate","","",14,{"inputs":[{"name":"result"}],"output":{"name":"t"}}],[0,"misc","conv","This module defines some additional traits not *directly* tied to conversions.",null,null],[8,"Saturated","conv::misc","This trait indicates that values of a type can be logically \"saturated\".",null,null],[10,"saturated_max","","Returns the type's saturated, maximum value.",15,{"inputs":[{"name":"saturated"}],"output":{"name":"self"}}],[10,"saturated_min","","Returns the type's saturated, minimum value.",15,{"inputs":[{"name":"saturated"}],"output":{"name":"self"}}],[8,"InvalidSentinel","","This trait indicates that a type has an \"invalid\" sentinel value.",null,null],[10,"invalid_sentinel","","Returns the type's \"invalid\" sentinel value.",16,{"inputs":[{"name":"invalidsentinel"}],"output":{"name":"self"}}],[8,"SignedInfinity","","This trait indicates that a type has positive and negative \"infinity\" values.",null,null],[10,"neg_infinity","","Returns the type's positive infinity value.",17,{"inputs":[{"name":"signedinfinity"}],"output":{"name":"self"}}],[10,"pos_infinity","","Returns the type's negative infinity value.",17,{"inputs":[{"name":"signedinfinity"}],"output":{"name":"self"}}],[8,"ApproxFrom","conv","This trait is used to perform a conversion that is permitted to approximate the result, but *not* to wrap or saturate the result to fit into the destination type's representable range.",null,null],[16,"Err","","The error type produced by a failed conversion.",18,null],[10,"approx_from","","Convert the given value into an approximately equivalent representation.",18,{"inputs":[{"name":"approxfrom"},{"name":"src"}],"output":{"name":"result"}}],[8,"ApproxInto","","This is the dual of `ApproxFrom`; see that trait for information.",null,null],[16,"Err","","The error type produced by a failed conversion.",19,null],[10,"approx_into","","Convert the subject into an approximately equivalent representation.",19,{"inputs":[{"name":"approxinto"}],"output":{"name":"result"}}],[8,"ApproxScheme","","This trait is used to mark approximation scheme types.",null,null],[8,"TryFrom","","This trait is used to perform a conversion between different semantic types which might fail.",null,null],[16,"Err","","The error type produced by a failed conversion.",20,null],[10,"try_from","","Convert the given value into the subject type.",20,{"inputs":[{"name":"tryfrom"},{"name":"src"}],"output":{"name":"result"}}],[8,"TryInto","","This is the dual of `TryFrom`; see that trait for information.",null,null],[16,"Err","","The error type produced by a failed conversion.",21,null],[10,"try_into","","Convert the subject into the destination type.",21,{"inputs":[{"name":"tryinto"}],"output":{"name":"result"}}],[8,"ValueFrom","","This trait is used to perform an exact, value-preserving conversion.",null,null],[16,"Err","","The error type produced by a failed conversion.",22,null],[10,"value_from","","Convert the given value into an exactly equivalent representation.",22,{"inputs":[{"name":"valuefrom"},{"name":"src"}],"output":{"name":"result"}}],[8,"ValueInto","","This is the dual of `ValueFrom`; see that trait for information.",null,null],[16,"Err","","The error type produced by a failed conversion.",23,null],[10,"value_into","","Convert the subject into an exactly equivalent representation.",23,{"inputs":[{"name":"valueinto"}],"output":{"name":"result"}}],[8,"ConvUtil","","This extension trait exists to simplify using various conversions.",null,null],[11,"approx_as","","Approximate the subject to a given type with the default scheme.",24,{"inputs":[{"name":"convutil"}],"output":{"name":"result"}}],[11,"approx_as_by","","Approximate the subject to a given type with a specific scheme.",24,{"inputs":[{"name":"convutil"}],"output":{"name":"result"}}],[11,"into_as","","Convert the subject to a given type.",24,{"inputs":[{"name":"convutil"}],"output":{"name":"dst"}}],[11,"try_as","","Attempt to convert the subject to a given type.",24,{"inputs":[{"name":"convutil"}],"output":{"name":"result"}}],[11,"value_as","","Attempt a value conversion of the subject to a given type.",24,{"inputs":[{"name":"convutil"}],"output":{"name":"result"}}],[8,"ConvAsUtil","","This extension trait exists to simplify using various conversions.",null,null],[11,"approx","","Approximate the subject with the default scheme.",25,{"inputs":[{"name":"convasutil"}],"output":{"name":"result"}}],[11,"approx_by","","Approximate the subject with a specific scheme.",25,{"inputs":[{"name":"convasutil"}],"output":{"name":"result"}}],[14,"TryFrom!","","See the documentation for the [`macros`](./macros/index.html#tryfrom!) module for details.",null,null]],"paths":[[4,"GeneralError"],[4,"GeneralErrorKind"],[4,"FloatError"],[4,"RangeError"],[4,"RangeErrorKind"],[8,"Saturate"],[8,"UnwrapOk"],[8,"UnwrapOrInf"],[8,"UnwrapOrInvalid"],[8,"UnwrapOrSaturate"],[4,"NoError"],[3,"Unrepresentable"],[3,"NegOverflow"],[3,"PosOverflow"],[4,"Result"],[8,"Saturated"],[8,"InvalidSentinel"],[8,"SignedInfinity"],[8,"ApproxFrom"],[8,"ApproxInto"],[8,"TryFrom"],[8,"TryInto"],[8,"ValueFrom"],[8,"ValueInto"],[8,"ConvUtil"],[8,"ConvAsUtil"]]};
searchIndex['bitflags'] = {"items":[[0,"","bitflags","A typesafe bitmask flag generator.",null,null],[14,"bitflags!","","The `bitflags!` macro generates a `struct` that holds a set of C-style\nbitmask flags. It is useful for creating typesafe wrappers for C APIs.",null,null]],"paths":[]};
searchIndex['custom_derive'] = {"items":[[0,"","custom_derive","This crate provides a macro that enables the use of custom `derive` attributes.",null,null]],"paths":[]};
initSearch(searchIndex);
